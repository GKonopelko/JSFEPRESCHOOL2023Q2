DimaD1988

Здесь я расскажу про логику генератора карточек в пагинации.

\\\\\\\\\\\\Генератор пагинации\\\\\\\\\\\\
Если почитать задание по логике генератора пагинации и набросать всё это на бумаге, то мы увидим, что у него есть определённые условия:
1. Значения на ОДНОЙ странице НЕ повторяются;
2. Каждое значение повторяется РОВНО 6 раз;
3. Значения генерируется РОВНО 1 раз при загрузке сайта и НЕ МЕНЯЮТСЯ при перелистывании.

Иначе говоря, вначале мы можем сформировать абсолютно любой порадок из имеющихся элементов, но сделать так, чтобы между ЛЮБЫМИ двумя одинаковыми элементами было НЕ МЕНЬШЕ 5 других элементов. Иначе при пагинации на 6 карточек возможны "дубли"

Данное действие можно реализавать 4 этапа:
1. генерация "зерна" - мы же хотим НАСТОЯЩИЙ рандом;
2. Нарезка данного "зерна" на составные части;
3. Последовательная модификация каждого отдельного "суб-зерна" для финальной сборки;
4. Финальная сборка.

\\\\\\\\\\\\Генерация "зерна"\\\\\\\\\\\\
Здесь нам абсолютно не важно в каком порядке сгенерировать последовательность, главное "зерно" должно быть одинаковым по длинне массиву петов и все значения внутри него должны быть уникальными.

Для такой цели хорошо-бы написать пару функции: одна из которых генерировала бы уникальное значени в определённом диапозоне, а вторая пыталась бы заполнить "зерно" уникальными значениями до длинны петов.

return > [3, 1, 6, 7, 5, 2, 4, 0]

\\\\\\\\\\\\Нарезка "зерна"\\\\\\\\\\\\
Вышеуказанных функций достаточно, чтобы корректно работала пагинация на 8 карточек, но на других значениях возможно будут дубли. Самое время немного "ограничить" наш рандом.
Максимальное количество после 8 - это 6, следовательно нужно убедиться что между ЛЮБЫМИ идентичным значениями будет минимум 5 элементов.
Для этого предлагаю нарезать данное зерно на три части:
БЫЛО - [3, 1, 6, 7, 5, 2, 4, 0]
СТАЛО - [3, 1, 6] [7, 5, 2] [4, 0]
Теперь мы можем перемешивать значения внутри "суб-зерна" и при слиянии в один массив мы ГАРАНТИРОВАННО будем иметь отступ в пять элементов

\\\\\\\\\\\\Модификация "суб-зерна"\\\\\\\\\\\\
Всё просто - мы знаем длинну "суб-зерна" (3, либо 2), знаем возможное число комбинации (6 + 2) - думаю не надо объяснять что нужно делать.

\\\\\\\\\\\\Финальная сборка.\\\\\\\\\\\\
1. Создайте пустой массив - [].
2. Положите последовательно ВСЕ модифицируемые "суб-зЁрна" в массив.
3. Повторите пункт 2 ещё пять раз.

БЫЛО - [3, 1, 6] [7, 5, 2] [4, 0]
СТАЛО - (48) [6, 3, 1, 7, 5, 2, 4, 0, 1, 3, 6, 5, 7, 2, 4, 0, 1, 6, 3, 5, 2, 7, 4, 0, 3, 6, 1, 7, 2, 5, 4, 0, 1, 3, 6, 5, 7, 2, 4, 0, 6, 3, 1, 7, 5, 2, 4, 0]

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Генерация html
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Первый этап выполнен и у вас есть значения, на основе которых можно брать информацию из JSON файла и генерировать карточки

Настоятельно рекомендую познакомиться с "insertAdjacentHTML" и попрактиковаться самостоятельно (пока дам маленькую подсказку):
///////////////////////
const text-box = document.querySelector('.text-box');
text-box.innerHTML = '';
const helloA = `Hello Word`;
const helloB = `Hello World`;
const html = `
      <div>
          <p>${helloA}, ${helloB}!</p>
      </div>
    `;
text-box.insertAdjacentHTML('afterbegin', html);
///////////////////////

Касаемо кнопок - думаю, это слишком просто, чтобы объяснять:
Всего четыре кнопки - всего  четыре простых логики.

DimaD1988